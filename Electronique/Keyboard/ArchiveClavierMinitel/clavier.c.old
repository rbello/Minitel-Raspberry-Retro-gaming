#include <wiringPi.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <linux/uinput.h>

int fd;
struct input_event evClavier, synEv;
int i, j;
struct uinput_user_dev uidev;

int valeurDuBit(int octet, int bit) {
	octet = octet & (1 << bit);
	octet = (octet >> bit);
	return octet;
}

int main (void) {
	// Clavier           { 2,  7,  8,  9, 10, 11,12, 17}
	int portSortie [8] =    {20, 12, 13, 14, 11, 10, 6, 15}; // Port wiringPi
	// int portSortie [8] = { 4, 19, 21, 23, 26, 24, 22, 8}; // Port Physique final
	// int portSortie [8] = { 8, 10, 12, 16, 18, 22, 24, 26}; // Prototype

	// Clavier            { 3,  4,  5,  6, 13, 14, 15, 16}
	int portLecture [8] =      {7, 0, 2, 3, 5, 4, 1, 16}; // Port wiringPi
	// int portLecture [8] = { 7, 11, 13, 15, 18, 16, 12, 10}; // Port Physique
	// int portLecture [8] = { 5,  7, 11, 13, 15, 19, 21, 23}; // Prototype

	uint8_t controleTouche[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	int tableau [8][8] = {{KEY_UP, KEY_BACKSPACE, KEY_F3, KEY_DOWN, KEY_RIGHTSHIFT, KEY_LEFT, KEY_RIGHT, KEY_ENTER},
		{KEY_T, KEY_E, KEY_R, KEY_Y, KEY_SEMICOLON, KEY_MINUS, KEY_SLASH, KEY_LEFTBRACE},
		{KEY_G, KEY_D, KEY_F, KEY_H, KEY_KPASTERISK, KEY_7, KEY_4, KEY_1},
		{KEY_DOT, KEY_ESC, KEY_COMMA, KEY_APOSTROPHE, KEY_TAB, KEY_F4, KEY_KPENTER, KEY_F5},
		{KEY_B, KEY_C, KEY_V, KEY_N, KEY_0, KEY_8, KEY_5, KEY_2},
		{KEY_F7, KEY_Z, KEY_A, KEY_F2, KEY_U, KEY_I, KEY_O, KEY_P},
		{KEY_F6, KEY_S, KEY_Q, KEY_LEFTCTRL, KEY_J, KEY_K, KEY_L, KEY_M},
		{KEY_F1, KEY_X, KEY_W, KEY_SPACE, KEY_RIGHTBRACE, KEY_9, KEY_6, KEY_3}};
	
	// WiringPi
	wiringPiSetup () ;

	for (i = 0; i < 8; i++) {
		pinMode(portSortie[i], OUTPUT);
		digitalWrite(portSortie[i], HIGH);
		pinMode(portLecture[i], INPUT);
		pullUpDnControl(portLecture[i], PUD_UP); // Met une résistance de tirage interne au VCC
	}
	
	// Initialisation du clavier
	fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);
	if (fd < 0) perror("Can't open /dev/uinput");
	if (ioctl(fd, UI_SET_EVBIT, EV_KEY) < 0) perror("Can't SET_EVBIT");
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			if (ioctl(fd, UI_SET_KEYBIT, tableau[i][j]) < 0) perror("Can't SET_KEYBIT");
		}
	}
	memset(&uidev, 0, sizeof(uidev));
	snprintf(uidev.name, UINPUT_MAX_NAME_SIZE, "clavierGPIO");
	uidev.id.bustype = BUS_USB;
	uidev.id.vendor  = 0x01;
	uidev.id.product = 0x01;
	uidev.id.version = 1;
	if (write(fd, &uidev, sizeof(uidev)) < 0) perror("write failed");
	if (ioctl(fd, UI_DEV_CREATE) < 0) perror("DEV_CREATE failed");
	memset(&evClavier, 0, sizeof(evClavier));
	evClavier.type  = EV_KEY;
	synEv.type  = EV_SYN;
	synEv.code  = SYN_REPORT;
	synEv.value = 0;
	
	// Boucle principale
	while(1) {
		for (i = 0; i < 8; i++) {
			digitalWrite(portSortie[i], LOW);
			delay(5); // Anti rebonds
			for (j = 0; j < 8; j++) {
				if (digitalRead(portLecture[j]) != valeurDuBit(controleTouche[i], j)) {
					if (digitalRead(portLecture[j]) == 0) {
						controleTouche[i] &= ~(1 << j);
						evClavier.code = tableau[i][j];
						evClavier.value = 1; // Touche pressée
						write(fd, &evClavier, sizeof(struct input_event));
						write(fd, &synEv, sizeof(synEv));
					} else {
						controleTouche[i] |= (1 << j);
						evClavier.code = tableau[i][j];
						evClavier.value = 0; // Toucje relachee
						write(fd, &evClavier, sizeof(struct input_event));
						write(fd, &synEv, sizeof(synEv));
					}
				}
			}
			digitalWrite(portSortie[i], HIGH);
		}
	}
	return 0 ;
}